<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"/>
  <title>Monstersmith: Pocket Brawl (MVP)</title>
  <link rel="stylesheet" href="styles.css">
  <style>
    @font-face {
      font-family: 'PressStart2P';
      src: local('Press Start 2P'), local('PressStart2P');
    }
  </style>
</head>
<body>
  <div id="app">
    <div id="hud">
      <div class="title">Monstersmith: Pocket Brawl</div>
      <div id="instructions">Tap a move. Win by dropping the enemy HP to zero.</div>
    </div>
    <canvas id="game"></canvas>
    <div id="controls"></div>
  </div>

  <script>
(() => {
  // ====== Utility ======
  const DPR = Math.max(1, Math.min(window.devicePixelRatio || 1, 2));
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  const controls = document.getElementById('controls');
  const instructions = document.getElementById('instructions');

  function resize() {
    const w = Math.min(window.innerWidth, 960);
    const h = Math.min(window.innerHeight - 140, 540);
    canvas.style.width = w + 'px';
    canvas.style.height = h + 'px';
    canvas.width = Math.floor(w * DPR);
    canvas.height = Math.floor(h * DPR);
    ctx.setTransform(DPR, 0, 0, DPR, 0, 0);
    draw();
  }
  window.addEventListener('resize', resize);

  // ====== Types & Effectiveness ======
  const Types = {
    FLAME: 'Flame',
    TIDE:  'Tide',
    TERRA: 'Terra'
  };

  const effectiveness = {
    // attacker->{defender: multiplier}
    [Types.FLAME]: {[Types.TERRA]: 0.5, [Types.TIDE]: 0.5, [Types.FLAME]: 1},
    [Types.TIDE]:  {[Types.FLAME]: 2,   [Types.TERRA]: 0.5, [Types.TIDE]: 1},
    [Types.TERRA]: {[Types.TIDE]: 2,    [Types.FLAME]: 2,   [Types.TERRA]: 1},
  };

  function typeMultiplier(moveType, targetType) {
    const row = effectiveness[moveType] || {};
    return row[targetType] ?? 1;
  }

  // ====== Creatures (original mashups) ======
  function creatureFactory(kind) {
    switch (kind) {
      case 'Ramhameleon': // ram + chameleon (Terra)
        return {
          name: 'Ramhameleon',
          type: Types.TERRA,
          maxHP: 120, hp: 120, atk: 18, def: 12, spd: 12,
          palette: ['#5a7d3a','#2e4d1e','#c2d36b','#754c24'],
          moves: [
            {name:'Headbutt', type: Types.TERRA, power: 22, acc: 1.0},
            {name:'Camouflage', type: Types.TERRA, power: 0,  acc: 1.0, buff:{def:+6}},
            {name:'Dust Kick', type: Types.TERRA, power: 16, acc: 0.95},
            {name:'Nature’s Grip', type: Types.TERRA, power: 26, acc: 0.85},
          ],
          draw(x, y, scale=1) {
            // Simple stylized silhouette with horns and curled tail
            ctx.save();
            ctx.translate(x, y);
            ctx.scale(scale, scale);
            // body
            ctx.fillStyle = this.palette[0];
            roundedRect(-40, -20, 80, 40, 16);
            ctx.fill();
            // legs
            ctx.fillStyle = this.palette[1];
            for (let i=0;i<4;i++){
              roundedRect(-30 + i*20, 20, 10, 22, 4); ctx.fill();
            }
            // head
            ctx.fillStyle = this.palette[2];
            roundedRect(30, -30, 28, 24, 8); ctx.fill();
            // horn
            ctx.fillStyle = this.palette[3];
            ctx.beginPath();
            ctx.moveTo(54, -28); ctx.quadraticCurveTo(70, -40, 60, -10); ctx.lineTo(54,-14); ctx.closePath();
            ctx.fill();
            // tail
            ctx.beginPath();
            ctx.moveTo(-40, 0); ctx.quadraticCurveTo(-60,-10,-55,10); ctx.quadraticCurveTo(-45,20,-38,12); ctx.fill();
            // eye
            ctx.fillStyle = '#000';
            ctx.fillRect(48,-22,4,4);
            ctx.restore();
          }
        };
      case 'Sharkopup': // shark + cockapoo (Tide)
        return {
          name: 'Sharkopup',
          type: Types.TIDE,
          maxHP: 100, hp: 100, atk: 22, def: 10, spd: 16,
          palette: ['#6bbbd5','#2b8aa6','#f0f7ff','#203a43'],
          moves: [
            {name:'Splash Snap', type: Types.TIDE, power: 20, acc: 0.95},
            {name:'Howl', type: Types.TIDE, power: 0, acc:1.0, buff:{atk:+6}},
            {name:'Whirlpool', type: Types.TIDE, power: 26, acc: 0.85},
            {name:'Puppy Chomp', type: Types.TIDE, power: 18, acc: 0.98},
          ],
          draw(x, y, scale=1) {
            ctx.save();
            ctx.translate(x, y);
            ctx.scale(scale, scale);
            // body
            ctx.fillStyle = this.palette[0];
            ellipse(-10, 0, 60, 30);
            // fin
            ctx.fillStyle = this.palette[1];
            triangle(10,-20, 30, -50, 50, -20);
            // tail
            triangle(-60,-10, -90, 0, -60, 10);
            triangle(-60,-5, -80, -20, -55, -15);
            // head (pup snout)
            ctx.fillStyle = this.palette[2];
            roundedRect(25,-10,30,18,6); ctx.fill();
            // eye
            ctx.fillStyle = this.palette[3];
            ctx.beginPath(); ctx.arc(8,-5,3,0,Math.PI*2); ctx.fill();
            ctx.restore();
          }
        };
      case 'Beetlebison': // beetle + bison (Flame, lore: overheating thorax)
      default:
        return {
          name: 'Beetlebison',
          type: Types.FLAME,
          maxHP: 110, hp: 110, atk: 20, def: 14, spd: 10,
          palette: ['#7a1f1f','#d64545','#3b1b1b','#ffcc66'],
          moves: [
            {name:'Ember Horn', type: Types.FLAME, power: 20, acc: 0.95},
            {name:'Overheat Vent', type: Types.FLAME, power: 26, acc: 0.85},
            {name:'Carapace', type: Types.FLAME, power:0, acc:1.0, buff:{def:+6}},
            {name:'Stampede', type: Types.FLAME, power:18, acc:0.98}
          ],
          draw(x, y, scale=1) {
            ctx.save();
            ctx.translate(x, y);
            ctx.scale(scale, scale);
            // body
            ctx.fillStyle = this.palette[0];
            ellipse(0, 0, 80, 40);
            // back shell
            ctx.fillStyle = this.palette[2];
            ellipse(10, -5, 60, 24);
            // head
            ctx.fillStyle = this.palette[1];
            roundedRect(30,-12,30,20,8); ctx.fill();
            // horn
            ctx.fillStyle = this.palette[3];
            triangle(45,-12, 70,-22, 55, 6);
            // legs
            ctx.fillStyle = this.palette[2];
            for (let i=0;i<4;i++){
              roundedRect(-30 + i*20, 18, 12, 20, 4); ctx.fill();
            }
            // eye
            ctx.fillStyle = '#000';
            ctx.fillRect(52,-6,4,4);
            ctx.restore();
          }
        };
    }
  }

  // ====== Moves, Damage, RNG ======
  const rng = {
    seed: Date.now() % 2147483647,
    next() {
      // Park-Miller minimal standard
      this.seed = (this.seed * 48271) % 2147483647;
      return this.seed / 2147483647;
    },
    chance(p) { return this.next() < p; }
  };

  function calcDamage(attacker, defender, move) {
    if (move.power <= 0) return 0;
    const base = move.power + Math.max(1, attacker.atk - Math.floor(defender.def * 0.6));
    const stab = (move.type === attacker.type) ? 1.2 : 1.0; // Same-Type bonus
    const multi = typeMultiplier(move.type, defender.type);
    const variance = 0.9 + rng.next() * 0.2;
    return Math.max(1, Math.floor(base * stab * multi * variance));
  }

  // ====== Game State ======
  const player = {
    creature: creatureFactory('Ramhameleon'),
    x: 140, y: 290, facing: 1
  };
  const enemy = {
    creature: creatureFactory(rng.next() > 0.5 ? 'Sharkopup' : 'Beetlebison'),
    x: 520, y: 140, facing: -1
  };

  let log = ['A wild ' + enemy.creature.name + ' appears!'];
  let playerTurn = true;
  let gameOver = false;
  let animTick = 0;

  // ====== UI: Move Buttons ======
  function updateControls() {
    controls.innerHTML = '';
    const c = player.creature;
    c.moves.forEach((m, i) => {
      const btn = document.createElement('button');
      btn.className = 'move';
      btn.innerHTML = `<div class="m-name">${m.name}</div><div class="m-type">${m.type}</div>`;
      btn.disabled = !playerTurn || gameOver;
      btn.addEventListener('click', () => doPlayerMove(i));
      controls.appendChild(btn);
    });
  }

  // ====== Turn Handling ======
  function doPlayerMove(i) {
    if (!playerTurn || gameOver) return;
    const move = player.creature.moves[i];
    executeMove(player.creature, enemy.creature, move, 'You');
  }

  function enemyChooseMove() {
    const ms = enemy.creature.moves;
    // Simple AI: prefer damaging moves and type advantage
    let best = 0, bestScore = -1;
    for (let i=0;i<ms.length;i++) {
      const m = ms[i];
      const base = (m.power || 0);
      const multi = typeMultiplier(m.type, player.creature.type);
      const score = (base ? base * multi : 5) + rng.next() * 4;
      if (score > bestScore) {bestScore = score; best = i;}
    }
    return ms[best];
  }

  function executeMove(attacker, defender, move, whoLabel) {
    if (move.buff) {
      // Apply buff
      if (move.buff.atk) attacker.atk += move.buff.atk;
      if (move.buff.def) attacker.def += move.buff.def;
      pushLog(`${whoLabel} used ${move.name}! ${move.buff.atk? 'ATK rose! ': ''}${move.buff.def? 'DEF rose!':''}`.trim());
      endPhase();
      return;
    }
    // Accuracy check
    if (!rng.chance(move.acc ?? 1)) {
      pushLog(`${whoLabel} used ${move.name}… but it missed!`);
      endPhase();
      return;
    }
    const dmg = calcDamage(attacker, defender, move);
    defender.hp = Math.max(0, defender.hp - dmg);
    const multi = typeMultiplier(move.type, defender.type);
    const extra = multi > 1 ? ' It\'s super effective!' : (multi < 1 ? ' It\'s not very effective…' : '');
    pushLog(`${whoLabel} used ${move.name}! ${dmg} damage.${extra}`);
    if (defender.hp <= 0) {
      gameOver = true;
      pushLog(`${whoLabel === 'You' ? 'Enemy ' + defender.name : 'You'} fainted!`);
      instructions.textContent = 'Tap "Restart" below to play again.';
    }
    endPhase();
  }

  function endPhase() {
    playerTurn = !playerTurn;
    updateControls();
    if (!playerTurn && !gameOver) {
      // Enemy acts after a short delay
      setTimeout(() => {
        const mv = enemyChooseMove();
        executeMove(enemy.creature, player.creature, mv, enemy.creature.name);
      }, 500);
    }
    draw();
  }

  function pushLog(t) {
    log.push(t);
    if (log.length > 6) log.shift();
    draw();
  }

  // ====== Drawing Helpers ======
  function roundedRect(x, y, w, h, r) {
    ctx.beginPath();
    ctx.moveTo(x+r, y);
    ctx.arcTo(x+w, y,   x+w, y+h, r);
    ctx.arcTo(x+w, y+h, x,   y+h, r);
    ctx.arcTo(x,   y+h, x,   y,   r);
    ctx.arcTo(x,   y,   x+w, y,   r);
    ctx.closePath();
  }
  function ellipse(cx, cy, w, h) {
    ctx.beginPath();
    ctx.ellipse(cx, cy, w/2, h/2, 0, 0, Math.PI*2);
    ctx.fill();
  }
  function triangle(x1,y1,x2,y2,x3,y3){
    ctx.beginPath(); ctx.moveTo(x1,y1); ctx.lineTo(x2,y2); ctx.lineTo(x3,y3); ctx.closePath(); ctx.fill();
  }

  function drawHPBar(x,y,w,h, hp, maxHP, label){
    // back
    ctx.fillStyle = '#222'; roundedRect(x,y,w,h,6); ctx.fill();
    // hp
    const pct = Math.max(0, hp/maxHP);
    ctx.fillStyle = pct > 0.5 ? '#4caf50' : (pct > 0.2 ? '#ff9800' : '#f44336');
    roundedRect(x+2,y+2,(w-4)*pct,h-4,5); ctx.fill();
    // text
    ctx.fillStyle = '#fff'; ctx.font = '12px system-ui, sans-serif'; ctx.textAlign='center'; ctx.textBaseline='middle';
    ctx.fillText(`${label} ${Math.max(0, Math.floor(hp))}/${maxHP}`, x + w/2, y + h/2);
  }

  // ====== Restart Control ======
  const restartBtn = document.createElement('button');
  restartBtn.className = 'restart';
  restartBtn.textContent = 'Restart';
  restartBtn.addEventListener('click', () => {
    Object.assign(player.creature, creatureFactory('Ramhameleon'));
    Object.assign(enemy.creature, creatureFactory(rng.next()>0.5?'Sharkopup':'Beetlebison'));
    log = ['A wild ' + enemy.creature.name + ' appears!'];
    playerTurn = true; gameOver = false;
    instructions.textContent = 'Tap a move. Win by dropping the enemy HP to zero.';
    updateControls(); draw();
  });
  controls.appendChild(restartBtn);

  // ====== Main Draw ======
  function draw() {
    const w = canvas.clientWidth;
    const h = canvas.clientHeight;
    ctx.clearRect(0,0,canvas.width,canvas.height);

    // background
    const g = ctx.createLinearGradient(0,0,0,h);
    g.addColorStop(0, '#87cefa'); // sky
    g.addColorStop(1, '#b6e3a8'); // grass
    ctx.fillStyle = g;
    ctx.fillRect(0,0,w,h);

    // simple stage ovals
    ctx.fillStyle = 'rgba(0,0,0,0.1)';
    ellipse(160, h-80, 180, 40);
    ellipse(w-160, h-220, 200, 50);

    // enemy
    enemy.creature.draw(w-220, 150, 1.2);

    // player
    player.creature.draw(200, h-120, 1.2);

    // UI boxes
    drawHPBar(40, 24, 280, 24, enemy.creature.hp, enemy.creature.maxHP, enemy.creature.name);
    drawHPBar(w-320, h-90, 280, 24, player.creature.hp, player.creature.maxHP, player.creature.name);

    // log box
    const logH = 90;
    ctx.fillStyle = 'rgba(0,0,0,0.35)';
    roundedRect(20, h - logH - 120, w-40, logH, 10); ctx.fill();
    ctx.fillStyle = '#fff';
    ctx.font = '14px system-ui, sans-serif';
    ctx.textAlign = 'left'; ctx.textBaseline='top';
    for (let i=0;i<log.length;i++){
      ctx.fillText(log[i], 30, h - logH - 110 + i*16);
    }
  }

  // init
  updateControls();
  resize();
  pushLog('You send out ' + player.creature.name + '!');
  draw();
})();
  </script>
</body>
</html>
